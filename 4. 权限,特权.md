* [对数据段特权检查](#1)
* [对直接转移的代码段特权检查](#2)
* [栈段的检查](#3)
* [调用门的检查](#4)
* [栈切换](#5)
* [栈切换涉及到的TSS](#6)


权限问题:
* 由于CPL,DPL 无法完整表达权限的问题. 
例如用户程序(CPL=3)通过调用门(将调用到内核过程,从低权限到高权限)执行,此时CPL=0,此时可以为所欲为.
* 因此加入RPL.此参数由操作系统来保证,CPU仅使用
* 1. RPL: 想以哪种权限去访问, 操作系统来填写, 一个自由的参数, CPU根据此参数去判断
* 2. 描述符里的DPL=CPL=CS选择子中的RPL(16位中的低2位)
* 3. DPL:访问此描述符的权限


<h2 id="1">对于数据段的特权检查:</h2>

从大方向说:只要权限比数据段大 ，或者相等就OK
实际根据以下几个步骤:
CPL:当前CS段的RPL, RPL:请求这个数据段的权限(自由参数,由操作系统自己决定), DPL: 数据段的权限
* 1. 根据CPL, RPL , DPL 这3个来检查
* 2. CPL <= DPL && RPL <= DPL

## 假设有 数据段 DPL= 2:
|代码段CPL=0|代码段CPL=1|代码段CPL=2|代码段CPL=3|
|-|-|-|-|
|RPL=0 可访问|RPL=1可访问|RPL=2可访问|RPL=3 不可访问|
|RPL=1或2 可访问|RPL=0 可访问|RPL=1 可访问|RPL=2 不可访问|
|RPL=3 不可访问|RPL=2可访问|RPL=0可访问|RPL=1不可访问|

* 可以看到CPL=0的代码段,即使有最高权限,但如果RPL=3,也无法访问
* 至于CPL=3的代码段,无论如何都无法访问,毕竟CPL>DPL


<h2 id="2"> 对跳转或调用的代码段检查</h2>

### 这里特指 call far , jmp far
* jmp , call ,ret 这些都是段内的, 不需要重新加载cs , 因此不做检查
* 1. 调用过程的CPL,RPL
* 2. 转移到此处的目标描述符的DPL,C(是否是一致性代码段)
* 综上CPL,RPL,DPL,C 4项参与检查
* 又根据C 进行分别检查  if ( 1==C ){ 一致性代码段检查} else { 非一致性代码段检查}
  
## 如果C=0, 非一致性代码段的检查:
* CPL == DPL , 必须是相同特权级, 否则产生异常
* 由于只能是平级跳转,因此转移前后CPL不变
* 对于RPL: RPL<=CPL即可,毕竟RPL是一种希望用哪种方式(权限)去访问,RPL并不会影响CPL,RPL只用于检查

### 假设非一致性代码段的描述符:DPL=2,C=0
|非一致性代码段描述符|代码段CPL=1|代码段CPL=2|代码段CPL=3|
|-|-|-|-|
|现有非一致性代码段的描述符:DPL=2,C=0|CPL不一致,RPL=0~3都不可转移|RPL=0~2都可以转移,RPL=3则无法转移|CPL不一致,RPL=0~3都无法转移|
|-|-|成功转移后,CPL不变,RPL只用作检查,即使rpl != CPL,转移后CPL也不变 |-|



## C=1, 一致性代码段检查(依从性)
* RPL不参与检查
* 满足: CPL>=DPL(一致性代码段), 也就是当前特权比目标代码段低或相等即可
* 一旦转移后, CPL不改变,依旧保持之前调用者的

### 假设一致性代码段的描述符:DPL=1,C=1
|一致性代码段描述符|代码段CPL=1|代码段CPL=2|代码段CPL=3|代码段CPL=0|
|-|-|-|-|-|
|一致性代码段的描述符:DPL=1,C=1|可以访问|可以访问|可以访问|不可以访问|

* RPL不参与检查,转移成功后CPL不改变
  

### 综上
* 对于代码段, 主要还是看CPL
* 对于数据段,需要RPL来辅助检查

<h2 id="3">栈段检查</h2>

* CPL=RPL=DPL

<h2 id='4'>调用门检查</h2>

* 通过调用门可以执行一个高于本CPL的过程
* 调用门指向了某个代码段内的某一个过程
* 调用门是一个描述符(8个字节),S=0 ,意味着这是一个系统段描述符, 可以存放在GDT或LDT中
* 调用门本身也有DPL,想要使用调用门,调用者的CPL<=调用门DPL,也就需要达到使用调用门的权限
* 访问调用门可以使用 jmp  , call 
* 一旦访问了调用门,检查顺利后,根据调用门描述符内的 段选择子获取段描述符的基址 + 调用门内的偏移地址,就这个过程的线性地址
* 调用门是一个系统段描述符(S=0,TYPE=1100),格式:
  
|31  ~  16|15|14 ~ 13|12|11 ~ 8|7 ~  5|  4  ~  0|
|-|-|-|-|-|-|-|
段内偏移高16位|P|DPL|0|TYPE(1100)|000|参数个数|

|31 ~  16|15 ~ 0|
|-|-|
|段选择子|段内偏移低16位|

* 调用门需要4项检查:
* 当前调用者的CPL
* 调用门选择子RPL (操作系统 自己维护)
* 调用门描述符DPL
* 目标代码段描述符的DPL
* 检查2步:
* 1. 首先要满足 本身能够访问调用门:CPL <= 门DPL, RPL <= 门DPL
* 2. 下表格:

|指令| 一致性代码段|非一致性代码段|
|-|-|-|
|call|代码段描述符DPL<=CPL|代码段描述符DPL<=CPL|
|jmp|代码段描述符DPL<=CPL|代码段描述符DPL=CPL|
|call 指令,栈切换| CPl不发生变化,栈不切换| CPL变成目标代码段的DPL,栈需要切换|
|jmp 指令,栈切换|CPL不变,栈不切换|由于DPL=CPL,栈不切换|

* 再一次的强调,权限无法从高到低
* 只有CPL变了,栈才会变,因此上面只有当call指令调用 非一致性代码段的时候, 才会切换栈, 除非CPL=DPL(例如CPL=0,目标代码段描述符的DPL=0)
* 综上:
* 对于一致性代码段: CPL>=目标代码段DPL, 不论JMP,CALL, 转移后CPL不变,栈不变
* 对于非一致性代码段: 
* 1. CALL指令要求: CPL >= 目标代码段DPL , CPL变成目标代码段DPL, 切换栈(除非CPL=DPL,那么栈不变)
* 2. JMP 指令: CPL = 目标代码段DPL , CPL不变,栈不变
* 
* 看上去内容有点多,需要到处判断,一会门检查,一会代码段DPL检查,还要考虑栈切换的问题
* 实际没那么麻烦,也就2条需要注意的
*  1. 一个是有权限访问门 ,也就是本身权限至少要与门相等 数值上: CPL <= 门DPL, RPL <=门DPL
*  2. 调用者代码段的权限,要低于代码段或相等,也就是低权限到高权限,那么数值上: CPL>= 目标代码段DPL
*  jmp 不涉及栈的问题, call 会 push cs push eip 因此会改变栈
*  至于jmp 和 call 的区别不用记, 让CPU产生保护性异常(GP)告诉我们即可,一旦产生异常说明此处jmp 指令有问题了( CPL != DPL)
*  对于栈的问题,一句话就解决,CPL一变, 栈跟着变 ; CPL不变,栈也不变
  
### 调用门的首次检查例子:
|门描述符|代码段A|代码段B|代码段C|代码段D|-|
|-|-|-|-|-|-|
|门DPL=3|CPL=3|CPL=2|CPL=1|CPL=0|代码段A,B,C,D任意+RPL=0~3都可以访问|
|门DPL=2|CPL=3,RPL=0~3都无法访问|CPL=2,RPL=0~2可以访问,RPL=3无法访问|CPL=1,RPL=0~2可以访问,RPL=3无法访问|CPL=0,RPL=0~2可以访问,RPL=3无法访问|A的CPL权限不足以访问门DPL;B,C,D的CPL全部满足,同时:RPL<=门DPL|

<h2 id="5"> 栈切换</h2>

* 栈切换与TSS相关,TSS(任务状态段),TSS保存了当前任务所有寄存器,以及特权0,1,2栈(这些栈需要由操作系统自己创建,CPU帮你使用); TSS在下面有讲

* 用于call 指令的调用门, 只有call 指令对非一致代码段会改变CPL. 因此栈会切换
* 对于用户层:CPL=3. 一般情况下定义额外3个栈,分别对应特权0,1,2. 
* 用户层自己的栈放在ss,esp,因此不需要额外定义
* 如果用户层能确定使用的调用门只使用特权0的过程,那么可以只额外定义特权0的栈,也就是用户层自己一个栈,特权0一个栈
* 切换栈的流程:
* 1. 目标代码段(被调用代码段) 会根据自己的DPL.从TSS中选择一个当前特权的栈
* 2. 由于执行完后将返回到之前的代码段中, 因此将先临时保存调用者的SS,esp
* 3. 把TSS中对应特权的栈给:ss,esp赋值
* 4. 把临时保存的SS,ESP, push 到特权栈中
* 5. 根据调用门描述符中的参数个数, 把调用者栈中的参数复制到 特权栈; 如有3个参数,则复制12字节(3*4, 以32位调用门为例, 如果是16位调用门则每个参数2个字节)
* 6. 把调用者的cs,eip ,push 到特权栈,用于之后返回
* 7. 把调用门中的段选择子,加载到cs,  eip = 偏移地址. 开始执行
* 第6步 跟段间调用的流程类似, 只是不在自己的栈中push, 而是在对应的特权栈中push

|调用者的栈|被调用者,特权栈(此栈的段选择子在TSS中)|
|-|-|
|参数3| 调用者ss|
|参数2|调用者ESP位置|
|参数1,esp位置|参数3|
|-|参数2|
|-|参数1|
|-|调用者cs|
|-|调用者eip|

## 返回问题
* 同一特权级别的 近返回 (ret ) 仅会检查界限问题, 再次强调同一特权不涉及栈切换
* 对于特权改变的远返回, 只能返回特权小的代码段
* 根据特权栈中的cs段选择子的低2位(RPL)来判定:
* 1. 如果 当前CPL = 目标cs.RPL 说明是同一级别的段间远返回 (pop eip , pop cs)
* 2. 当前CPL < 目标CS.RPL 也就是 当前CPL <目标DPL ,这是特权需要改变的远返回(需要pop eip,pop cs,pop esp, pop ss)
* 3. 例如当前CPL=0, 目标(DPL)CS.RPL=3.这符合条件
* 
* 假设当前是用户程序CPL=3,特权0的被调用过程,有3个参数被传递进来(通过调用门),结尾处: retf 12,返回流程:
* 1. 首先特权0栈:pop eip,pop cs
* 2. 当前有3个参数,每个参数4个字节,结尾是retf 12. 需要回收特权0栈的参数空间: esp + 12
* 3. 参数上面是用户的ss,esp,因此:pop esp,pop ss
* 4. 用户esp+12.还原用户栈空间.(特权0栈的参数是从用户栈中复制的)
* 5. 此时,cs,eip,ss,esp 这4项全部还原. 同时检查其余段寄存器:ds,es,gs,fs 如果指向的段描述符权限比CPL高(CPL > 段DPL),则把对应段寄存器置0,例如: mov ds,0
* 
* 因为如果特权0代码段中如果使用了DPL=0的ds,但忘了还原ds(一开始没有push ds, 最后没有pop ds).回到用户代码段时ds还指向DPL=0的描述符.
* 特权检查只在 mov ds,0xXXX 这个时候(这在特权0中操作的). 回到用户程序后,用户可以直接访问特权0的数据段


<h2 id="6">TSS(任务状态段)</h2>


* TSS不仅用于多个任务的切换,也用于特权栈的切换
* 就上面的栈切换来说,一旦CPL改变,就需要从任务对应的TSS中获取特权栈(1个任务对应1个TSS)
* TSS中包含了当前任务的所有寄存器,以及特权0,1,2的栈,这些栈需要我们自己创建
* TSS的任务切换:
* 一旦任务切换,TSS保存当前任务的所有寄存器(为了下一次运行的恢复). 下一个任务将从自己的TSS中恢复所有的寄存器,然后此任务从新加载的CS.eip开始继续执行
* 
* TSS本身一个结构,为了使用TSS,必须为其创建描述符. TSS描述符跟调用门描述符都是一种系统段描述符(S=0),但TYPE不同
* TSS的TYPE:1001 (非活动),TYPE:1011(繁忙), 繁忙标志是为了不让自己调用自己,防止递归
* TSS系统段描述符和LDT系统段描述符只能存放在GDT中
* TSS描述符的DPL可自定义
* 只要当前CPL <= TSS描述符的DPL,就可以访问此描述符,这意味着只要 CPL<=TSS.DPL 就可以调度任务
* 关于LDT:(局部描述符表)
* 1. LDT 用于为每个任务存放各种描述符的地方( 代码段 数据段), 主要是为了能与GDT中其他描述符隔离开,便于管理, 比如A,B,C,D 4个任务, 他们的各种描述符都放在自己的LDT中
* 2. CPU 厂商只是建议为每个任务 分配一个LDT一个TSS 来管理并运行一个任务,不代表这是一种强制
* 真正影响任务的是TSS,任务切换只与TSS有关. 至于LDT,取决于你自己
* 
* 综上:
* LDT:局部描述符表. 类似GDT,用于存放描述符. 每个任务的段描述符分开管理,让任务的段描述符都在自己的LDT中
* TSS是一种结构,用来表示一个任务,用于任务的切换,也用于特权栈的切换(低特权到高特权的代码段运行)
* 要使用TSS,必须为TSS创建描述符,且必须存放在GDT中
* 要使用LDT,必须为LDT创建描述符,且必须存放在GDT中
* 
* TSS的对应寄存器是TR, 使用LTR指令可加载到TR寄存器中, 其TYPE从1001变成1011(繁忙状态), 但并不会切换任务
* LDT对应的寄存器是LDTR, 使用LLDT指令可加载到LDTR寄存器中
* LTR TSS段选择子 => TR:TSS段选择子 
* LLDT LDT段选择子 => LDTR:LDT段选择子 ; 一旦LLDT加载完成, 局部描述符表生效, 可访问LDT中的描述符了



